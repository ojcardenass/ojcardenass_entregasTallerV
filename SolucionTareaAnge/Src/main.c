/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <BasicTimer.h>
#include <stdint.h>
#include <stm32f4xx.h>
#include "GPIOxDriver.h"
#include "ExtiDriver.h"

/* Para el enconder:
1.	Si la señal que tiene DT es igual a la señal de CLK, lo que hacemos es restar en el contador;
	si la señal de DT es contraria la señal de CLK, lo que hacemos es sumar en el contador.
2.	Con interrupciones lo mejor es usar el CLK con interrupciones de subida y bajada y cada vez que
	se produzca un flanco comprobamos el valor con DT, si hay flanco de subida en CLK y el valor de
	DT es 0, el sentido de giro es clockwise y debe incrementar el contador; si hay flanco de subida
	en CLK y el valor de DT es 1, el sentido es counter clockwise y debe decrementar el contador.

	PARA TENER EN CUENTA:
	A 11-16: PB10
	B 10-15: PB4
	C 3-8: PB0
	D 2-6: PC0
	E 1-5: PA4
	F 12-18: PB5
	G 7-17: PC1
	TDec 14: PB3
	TUni 13: PC2
*/

/* DEFINICIÓN DE LOS ELEMENTOS DEL SISTEMA */

/* Definimos los handlers necesarios*/

/* Handlers para manejo de LED2 y encoder*/
GPIO_Handler_t		handlerLED2 			= {0};
GPIO_Handler_t		handlerCLK 				= {0};
GPIO_Handler_t		handlerDT 				= {0};
GPIO_Handler_t		handlerSW 				= {0};

/* Handlers para manejo del 7 segmentos*/
GPIO_Handler_t 		handlerSegA 			= {0};
GPIO_Handler_t 		handlerSegB 			= {0};
GPIO_Handler_t 		handlerSegC 			= {0};
GPIO_Handler_t 		handlerSegD 			= {0};
GPIO_Handler_t 		handlerSegE 			= {0};
GPIO_Handler_t 		handlerSegF 			= {0};
GPIO_Handler_t 		handlerSegG 			= {0};

/**/
GPIO_Handler_t 		handlerTraUni 			= {0}; //Handlers para manejo de transistores
GPIO_Handler_t 		handlerTraDec			= {0};

/* Definimos los handlers de los timers*/
BasicTimer_Handler_t handlerBlinkyTimer 	= {0}; //Encargado del Blinky
BasicTimer_Handler_t handlerTimerPantalla 	= {0}; //Encargado del 7 segmentos

/* Elementos necesarios para configurar el EXTI */
EXTI_Config_t handlerPinCLK 				= {0};
EXTI_Config_t handlerPinSW 					= {0};

/* Variables a usar */
uint8_t counterEnc 							= 0;
int8_t counterSW 							= 0;
uint8_t FlagCLK 							= 0;
uint8_t FlagSW								= 0;




/* PROTOTIPOS DE LAS FUNCIONES DEL MAIN*/
/* Funciones a utilizar */
void inint_Devices(void);
void pantalla(uint8_t numero);
void culebrita(int8_t numero);

/**/
int main(void){
	/* Inicializamos todos los elementos del sistema*/
	inint_Devices();

	while(1){

		if(FlagSW == 0){
			/* Contador: Comparando valores de la bandera del CLK y el DT */
			/* Si se detecta un flanco de subida*/
			if (FlagCLK){
				/* Y la señal del data es contraria, es decir, cero */
				if (GPIO_ReadPin(&handlerDT) == 0){
					/* Si el contador es inferior a 99, sume 1 al contador */
					if (counterEnc < 99){
						counterEnc++; // Sentido CW
					}
					FlagCLK = 0;

				}
				/* Si la señal del data es igual, es decir, uno */
				else if (GPIO_ReadPin(&handlerDT) == 1){
					/* Si el contador es mayor a 0, reste 1 al contador */
					if (counterEnc > 0){
						counterEnc--; // Sentido CCW
					}
					FlagCLK = 0; /* Se baja la bandera en ambos casos para salir de la interrupción */
				}
			} // Fin If

			/* Verificación del estado del transistor de decenas */
			if(GPIO_ReadPin(&handlerTraDec) == RESET){
				GPIO_WritePin(&handlerTraDec, 0);
				GPIO_WritePin(&handlerTraUni, 1);
				pantalla(counterEnc%10); // Módulo, para obtener las unidades del contador
				}
			/* Verificación del estado del transistor de unidades */
			else if(GPIO_ReadPin(&handlerTraUni) == RESET){
				GPIO_WritePin(&handlerTraDec, 1);
				GPIO_WritePin(&handlerTraUni, 0);
				pantalla(counterEnc/10); // División entre enteros, para obtener las decenas del contador
				}
		} // FIN MODO NORMAL

		/* Apretando el botón del encoder */
		else if(FlagSW == 1){
			/* Contador: Comparando valores de la bandera del CLK y el DT */
			/* Si se detecta un flanco de subida*/
			if (FlagCLK){
				/* Y la señal del data es contraria, es decir, cero */
				if (GPIO_ReadPin(&handlerDT) == 0){
					/* Si el contador del SW es mayor o igual a 11, permanece en 0 */
					if (counterSW >=11){
						counterSW = 0; // Sentido CW
					}
					else{
						counterSW ++;
					}
					FlagCLK = 0;
				}
				/* Si la señal del data es igual, es decir, uno */
				else if (GPIO_ReadPin(&handlerDT) == 1){
					/* Si el contador SW es menor o igual a 0, permanece en 11 */
					if (counterSW <= 0){
						counterSW = 11; // Sentido CW
					}
					else{
						counterSW--;
					}
					FlagCLK = 0;
				}
			} // Fin If

			/* Defininiendo el modo culebrita */
			/* Posiciones en las cualesestán presentes las unidades */
			if(counterSW == 0 || counterSW == 5 || counterSW == 6 || counterSW == 9 ||
					counterSW == 10 || counterSW == 11){
				GPIO_WritePin(&handlerTraDec, 0);
				GPIO_WritePin(&handlerTraUni, 1);
				culebrita(counterSW); // Mostramos en el modo "culebrita"
			}
			/* Posiciones en las cualesestán presentes las decenas */
			else if(counterSW == 1 || counterSW == 2 || counterSW == 3 || counterSW == 4 ||
					counterSW == 7 || counterSW == 8){
				GPIO_WritePin(&handlerTraDec, 1);
				GPIO_WritePin(&handlerTraUni, 0);
				culebrita(counterSW); // Mostramos en el modo "culebrita"
			}
		} // FIN MODO CULEBRITA
	} // Fin While infinito
	return 0;
}



void inint_Devices(void){

	/* Configuración del LED2 - PA5 */
	handlerLED2.pGPIOx 								= GPIOA;
	handlerLED2.GPIO_PinConfig.GPIO_PinNumber 		= PIN_5;
	handlerLED2.GPIO_PinConfig.GPIO_PinMode 		= GPIO_MODE_OUT;
	handlerLED2.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerLED2.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerLED2.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	/* Cargar la configuración del LED2 en los registros del MCU*/
	GPIO_Config(&handlerLED2);

	GPIO_WritePin(&handlerLED2, SET);

	/* Configuración del TIM2 para que haga un blinky cada 250ms*/
	handlerBlinkyTimer.ptrTIMx 							= TIM2;
	handlerBlinkyTimer.TIMx_Config.TIMx_mode			= BTIMER_MODE_UP;
	handlerBlinkyTimer.TIMx_Config.TIMx_speed			= BTIMER_SPEED_1ms;
	handlerBlinkyTimer.TIMx_Config.TIMx_period			= 250;		//Lanza una interrupción cada 250ms.
	handlerBlinkyTimer.TIMx_Config.TIMx_interruptEnable = BTIMER_INTERRUPT_ENABLE;

	/* Cargando la configuración del TIM2 en los registros */
	BasicTimer_Config(&handlerBlinkyTimer);

	/* Configuración del EXTI - CLK - PC6 */
	/* Configuramos el pin como entrada digital*/
	handlerCLK.pGPIOx								= GPIOC;
	handlerCLK.GPIO_PinConfig.GPIO_PinNumber		= PIN_7;
	handlerCLK.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
	handlerCLK.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerCLK.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerCLK.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerCLK.GPIO_PinConfig.GPIO_PinAltFunMode	= AF0;

	// Cargando la configuración de los registros //
	GPIO_Config(&handlerCLK);

	//Interrupción//
	handlerPinCLK.pGPIOHandler = &handlerCLK;
	handlerPinCLK.edgeType = EXTERNAL_INTERRUPT_RISING_EDGE;
	//Cargando la interrupción del EXTI//
	extInt_Config(&handlerPinCLK);

	/* Configuración del EXTI - SW - PC9 */
	/* Configuramos el pin como entrada digital*/
	handlerSW.pGPIOx								= GPIOA;
	handlerSW.GPIO_PinConfig.GPIO_PinNumber			= PIN_12;
	handlerSW.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
	handlerSW.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerSW.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSW.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerSW.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

	// Cargando la configuración de los registros //
	GPIO_Config(&handlerSW);

	//Interrupción//
	handlerPinSW.pGPIOHandler = &handlerSW;
	handlerPinSW.edgeType = EXTERNAL_INTERRUPT_FALLING_EDGE;
	//Cargando la interrupción del EXTI//
	extInt_Config(&handlerPinSW);

	/* Configuración del EXTI- DT- PC8 */
	/* Configuramos el pin como entrada digital*/
	handlerDT.pGPIOx								= GPIOA;
	handlerDT.GPIO_PinConfig.GPIO_PinNumber			= PIN_11;
	handlerDT.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_IN;
	handlerDT.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerDT.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerDT.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_FAST;
	handlerDT.GPIO_PinConfig.GPIO_PinAltFunMode		= AF0;

	// Cargando la configuración en los registros //
	GPIO_Config(&handlerDT);

	/* CONFIGURACIÓN PARA EL MANEJO DEL 7 SEGMENTOS */

	/* Configuración del pin para el segmento A*/
	handlerSegA.pGPIOx								= GPIOC;
	handlerSegA.GPIO_PinConfig.GPIO_PinNumber		= PIN_3;
	handlerSegA.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSegA.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSegA.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSegA.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;

	//Cargando configuración en los registros//
	GPIO_Config(&handlerSegA);

	/* Configuración del pin para el segmento B*/
	handlerSegB.pGPIOx								= GPIOC;
	handlerSegB.GPIO_PinConfig.GPIO_PinNumber		= PIN_2;
	handlerSegB.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSegB.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSegB.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSegB.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;

	//Cargando configuración en los registros//
	GPIO_Config(&handlerSegB);

	/* Configuración del pin para el segmento C*/
	handlerSegC.pGPIOx								= GPIOC;
	handlerSegC.GPIO_PinConfig.GPIO_PinNumber		= PIN_1;
	handlerSegC.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSegC.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSegC.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSegC.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;

	//Cargando configuración en los registros//
	GPIO_Config(&handlerSegC);

	/* Configuración del pin para el segmento D*/
	handlerSegD.pGPIOx								= GPIOC;
	handlerSegD.GPIO_PinConfig.GPIO_PinNumber		= PIN_0;
	handlerSegD.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSegD.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSegD.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSegD.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;

	//Cargando configuración en los registros//
	GPIO_Config(&handlerSegD);

	/* Configuración del pin para el segmento E*/
	handlerSegE.pGPIOx								= GPIOB;
	handlerSegE.GPIO_PinConfig.GPIO_PinNumber		= PIN_0;
	handlerSegE.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSegE.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSegE.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSegE.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;

	//Cargando configuración en los registros//
	GPIO_Config(&handlerSegE);

	/* Configuración del pin para el segmento F*/
	handlerSegF.pGPIOx								= GPIOA;
	handlerSegF.GPIO_PinConfig.GPIO_PinNumber		= PIN_4;
	handlerSegF.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSegF.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSegF.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSegF.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;

	//Cargando configuración en los registros//
	GPIO_Config(&handlerSegF);

	/* Configuración del pin para el segmento G*/
	handlerSegG.pGPIOx								= GPIOA;
	handlerSegG.GPIO_PinConfig.GPIO_PinNumber		= PIN_1;
	handlerSegG.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSegG.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSegG.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSegG.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;

	//Cargando configuración en los registros//
	GPIO_Config(&handlerSegG);

	/* Configuración del pin para el Transistor de decenas */
	handlerTraDec.pGPIOx							= GPIOB;
	handlerTraDec.GPIO_PinConfig.GPIO_PinNumber		= PIN_5;
	handlerTraDec.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_OUT;
	handlerTraDec.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerTraDec.GPIO_PinConfig.GPIO_PinPuPdControl= GPIO_PUPDR_NOTHING;
	handlerTraDec.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;

	//Cargando configuración en los registros//
	GPIO_Config(&handlerTraDec);

	/* Configuración del pin para el Transistor de unidades */
	handlerTraUni.pGPIOx							= GPIOB;
	handlerTraUni.GPIO_PinConfig.GPIO_PinNumber		= PIN_4;
	handlerTraUni.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_OUT;
	handlerTraUni.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerTraUni.GPIO_PinConfig.GPIO_PinPuPdControl= GPIO_PUPDR_NOTHING;
	handlerTraUni.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;

	//Cargando configuración en los registros//
	GPIO_Config(&handlerTraUni);

	/* Configuración del TIM4 para encender el 7 segmentos, aparentemente se mostrará como si
	 * estuviesen encendidos al tiempo */
	handlerTimerPantalla.ptrTIMx 							= TIM5;
	handlerTimerPantalla.TIMx_Config.TIMx_mode				= BTIMER_MODE_UP;
	handlerTimerPantalla.TIMx_Config.TIMx_speed				= BTIMER_SPEED_1ms;
	handlerTimerPantalla.TIMx_Config.TIMx_period			= 6;		//Lanza una interrupción cada 6ms.
	handlerTimerPantalla.TIMx_Config.TIMx_interruptEnable 	= BTIMER_INTERRUPT_ENABLE;

	/**Cargando la configuración del TIM4 en los registros*/
	BasicTimer_Config(&handlerTimerPantalla);

} /*Fin del inint_Devices*/

void pantalla(uint8_t numero){

	/* Hacemos un switch case para definir qué segmentos deben encenderse de acuerdo al número
	 * mostrado. Tener en cuenta que el Display es ánodo común; por esto usamos RESET.*/

	switch (numero){

	case 0:
		// Para mostrar el número 0 en pantalla.
		GPIO_WritePin(&handlerSegA, RESET);
		GPIO_WritePin(&handlerSegB, RESET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, RESET);
		GPIO_WritePin(&handlerSegE, RESET);
		GPIO_WritePin(&handlerSegF, RESET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 1:
		// Para mostrar el número 1 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, RESET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 2:
		// Para mostrar el número 2 en pantalla.
		GPIO_WritePin(&handlerSegA, RESET);
		GPIO_WritePin(&handlerSegB, RESET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, RESET);
		GPIO_WritePin(&handlerSegE, RESET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, RESET);

		break;

	case 3:
		// Para mostrar el número 3 en pantalla.
		GPIO_WritePin(&handlerSegA, RESET);
		GPIO_WritePin(&handlerSegB, RESET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, RESET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, RESET);

		break;

	case 4:
		// Para mostrar el número 4 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, RESET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, RESET);
		GPIO_WritePin(&handlerSegG, RESET);

		break;

	case 5:
		// Para mostrar el número 5 en pantalla.
		GPIO_WritePin(&handlerSegA, RESET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, RESET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, RESET);
		GPIO_WritePin(&handlerSegG, RESET);

		break;

	case 6:
		// Para mostrar el número 6 en pantalla.
		GPIO_WritePin(&handlerSegA, RESET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, RESET);
		GPIO_WritePin(&handlerSegE, RESET);
		GPIO_WritePin(&handlerSegF, RESET);
		GPIO_WritePin(&handlerSegG, RESET);

		break;

	case 7:
		// Para mostrar el número 7 en pantalla.
		GPIO_WritePin(&handlerSegA, RESET);
		GPIO_WritePin(&handlerSegB, RESET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 8:
		// Para mostrar el número 8 en pantalla.
		GPIO_WritePin(&handlerSegA, RESET);
		GPIO_WritePin(&handlerSegB, RESET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, RESET);
		GPIO_WritePin(&handlerSegE, RESET);
		GPIO_WritePin(&handlerSegF, RESET);
		GPIO_WritePin(&handlerSegG, RESET);

		break;

	case 9:
		// Para mostrar el número 9 en pantalla.
		GPIO_WritePin(&handlerSegA, RESET);
		GPIO_WritePin(&handlerSegB, RESET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, RESET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, RESET);
		GPIO_WritePin(&handlerSegG, RESET);

		break;

	default:
		break;
	}
}

void culebrita(int8_t numero){

	switch (numero){

	case 0:
		// Para mostrar el número 0 en pantalla.
		GPIO_WritePin(&handlerSegA, RESET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 1:
		// Para mostrar el número 1 en pantalla.
		GPIO_WritePin(&handlerSegA, RESET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 2:
		// Para mostrar el número 2 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, RESET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 3:
		// Para mostrar el número 3 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, RESET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 4:
		// Para mostrar el número 4 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, RESET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 5:
		// Para mostrar el número 4 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, RESET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 6:
		// Para mostrar el número 5 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, RESET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 7:
		// Para mostrar el número 6 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, RESET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 8:
		// Para mostrar el número 7 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 9:
		// Para mostrar el número 8 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, RESET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 10:
		// Para mostrar el número 9 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, SET);
		GPIO_WritePin(&handlerSegC, RESET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	case 11:
		// Para mostrar el número 9 en pantalla.
		GPIO_WritePin(&handlerSegA, SET);
		GPIO_WritePin(&handlerSegB, RESET);
		GPIO_WritePin(&handlerSegC, SET);
		GPIO_WritePin(&handlerSegD, SET);
		GPIO_WritePin(&handlerSegE, SET);
		GPIO_WritePin(&handlerSegF, SET);
		GPIO_WritePin(&handlerSegG, SET);

		break;

	default:
		break;
	}
}

/* Callback del Timer 2, hacemos blinky, led de estado */
	void BasicTimer2_Callback(void){
		GPIOxTooglePin(&handlerLED2);
	}

/* Callback del EXTI_6*/
	void callback_extInt7(void){
		// Bandera que indica que se detectó un flanco de subida
		FlagCLK = 1;
	}

/* Callback del EXTI_9 para el botón del encoder*/
	void callback_extInt12(void){
		// Bandera que indica que se presionó el botón del encoder
		FlagSW ^=1;
	}

/* Callback del timer 5 para dar la apariencia de los números a la vez en el 7 segmentos */
	void BasicTimer5_Callback(void){
		GPIOxTooglePin(&handlerTraUni);
		GPIOxTooglePin(&handlerTraDec);
	}

